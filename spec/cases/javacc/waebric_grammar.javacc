/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\waebric_grammar.jj */
/*@egen*/options {
 	JDK_VERSION = "1.5";
  	             
  	               
} 

PARSER_BEGIN(WaebricParser) 

import java.io.*;

public class WaebricParser/*@bgen(jjtree)*/implements WaebricParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTWaebricParserState jjtree = new JJTWaebricParserState();

/*@egen*/
 	public static void main(String[] args) {
    	
    	// Check if user has used arguments
    	if(args.length == 0){
    		System.out.println("No arguments found: Please run -> WaebricParser filename.wae");
    		System.out.println("Current working directory: " + System.getProperty("user.dir"));
    		System.exit(0);
    	}
    	
    	// Reader set to null te avoid init problems
    	Reader sr = null;
    	
    	// Load waebric data from file
    	try {
    		sr = new FileReader(new File(args[0]));
   		}catch(FileNotFoundException filenotfound) {
    		System.out.println("File not found:");
    		filenotfound.printStackTrace();
    		System.exit(0); 
    	}
    	
    	WaebricParser p = new WaebricParser(sr);
    
    	try {
    		// Begin parsing with the first Module node
      		SimpleNode n = p.Modules();
      		
      		// Save AST tree into String
	  		String ast = buildAST( n, 0);
	  		System.out.println("AST:");
	  		System.out.println(ast);

/*
 			Code to produce a tree dump of the original jjTree. can be really useful for debugging
 			so we decided to leave it in.	  		
	  		System.out.println("");	  		System.out.println("Abstract syntax tree dump:");*/	  		n.dump("");

    	} catch (ParseException pe) {
      		pe.printStackTrace();
    	}
  	}
 
  	private static String buildAST(Node n, int childIndex) {	
  		ModulesVisitor moduleVisitor = new ModulesVisitor();
		n.jjtAccept(moduleVisitor, null);
		return moduleVisitor.getAST();
  	}
}

PARSER_END(WaebricParser)

/*
Lexer

The lexer uses 2 additional states on top of the DEFAULT state:
IN_PATH: ensures FileName can only be recognized within a Path() production.
	Would otherwise be unable to recognize tokens such as <IdCon>
IN_STRCON: ensures only StrChar tokens are recognized.
	Would otherwise be unable to recognize StrChar tokens because of IdCon
*/

// Comments, spaces and newlines are skipped by the parser
<*>
SKIP : {
		" "
	| 	"\t"
	| 	"\n"
	| 	"\r"
	| 	<"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| 	<"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

// Reserved keywords
<DEFAULT, IN_PATH>
TOKEN : {
		< MODULE : "module" >
	|	< IMPORT : "import" >
	|	< SITE : "site" > : IN_PATH
	|	< END : "end" > : DEFAULT
	|	< DEF : "def" >
	|	< IF : "if" >
	|	< ELSE : "else" >
	|	< EACH : "each" >
	|	< LET : "let" >
	|	< IN : "in" >
	|	< YIELD : "yield" >
	|	< COMMENT : "comment" > : IN_STRCON
	|	< ECHO : "echo" >
	|	< CDATA : "cdata" >
	|	< #LIST : "list" >
	|	< #RECORD : "record" >
	|	< #STRING : "string" >
}

// Separators
<DEFAULT, IN_STRCON>
TOKEN : {
		< LPAREN : "(" >
	|	< RPAREN : ")" > 
	|	< LBRACKET : "[" >
	|	< RBRACKET : "]" >
	|	< LBRACE : "{" >
	|	< RBRACE : "}" >
	|	< SEMICOLON : ";" > : DEFAULT
	|	< COLON : ":" >
	|	< COMMA : "," >
	|	< DOT : "." >
}

// Operators
<DEFAULT>
TOKEN : {
		< DOLLAR_SIGN: "$" >
	|	< NUMBER_SIGN: "#" >
	|	< ASSIGN : "=" >
	|	< AT : "@" >
	|	< QUESTIONMARK: "?" >
	|	< EXCLAMATION: "!" >
	|	< PERCENT : "%" >
	|	< PLUS : "+" >
}

// Start 'other' tokens
<IN_PATH>
TOKEN : {
	< #PathElement :
		(~[" ","\t","\n","\r",".","/","\\"])+
	>	
}

<IN_PATH>
TOKEN : {
	< FileName :
		<PathElement> <DOT> <FileExt>
	> : DEFAULT 
} 

<IN_PATH>
TOKEN : {
	< #FileExt :
		(["a"-"z","A"-"Z","0"-"9"])+
	>
}

<IN_PATH>
TOKEN : {
	< DirName :
		<Directory>
	>	
}

<IN_PATH>
TOKEN : {
	< #Directory :
		(<PathElement> "/")+
	>	
}

<DEFAULT>
TOKEN : {
	< IdCon :
		["A"-"Z","a"-"z"](["A"-"Z","a"-"z","-","0"-"9"])* 
	> 
}

<DEFAULT>
TOKEN : {
	< NatCon : 
		(["0"-"9"])+ 
	>
}

<DEFAULT>
TOKEN : {   
 	< SymbolCon : 
 		["'"] (<SymbolChar>)* 
 	>
}

<DEFAULT>
TOKEN : {
	< Text : 
		["\""] (<TextChar>)* ["\""] 
	>
}

<DEFAULT>
TOKEN : {
    < #TextChar : 
    		<TextCharRef> 
    	|	<EscQuote>
    	|	<Amp>
    	|	<TextEntityRef>
    	|	~["\0"-"\37","&","\"","<","\200"-"\377"] | ["\n","\r","\t"] 
    >
}

<DEFAULT>
TOKEN : {
    < #TextCharRef : 
    	"&#" (["0"-"9"])+ <SEMICOLON> | "&#x" (["0"-"9","a"-"f","A"-"F"])+ <SEMICOLON>
    >
}

<DEFAULT>
TOKEN : {
   	< #EscQuote : 
   		["\\"]["\""]
   	> 
}

<DEFAULT>
TOKEN : {
    < #Amp : 
    	["&"] 
    >
}

<DEFAULT>
TOKEN : {
   	< #TextEntityRef : 
   		"&" ["a"-"z","A"-"Z","_",":"] (["a"-"z","A"-"Z","0"-"9",".","-","_",":"])* <SEMICOLON> 
   	>
} 

<IN_STRCON>
TOKEN : {
	< StrCon :
		"\"" (< StrChar >)* "\""
	>
}

<DEFAULT>
TOKEN : {
	< #StrChar :
			"\n"
		|	"\t"
		|	"\\"
		|	"\\\\"
		|	"\\" (["0"-"9"]){3}
		|	~["\0"-"\37","\n","\t","\"","\\"]
	>
}
<DEFAULT>
TOKEN : {
	< Type :
			<LIST>
		|	<RECORD>
		|	<STRING>
	>
}

<DEFAULT>
TOKEN : {
	< PreText :
		"\"" (<TextChar>)* "<"
	>
}

<DEFAULT>
TOKEN : {
	< PostText :
		">" (<TextChar>)* "\""
	>	
}

<DEFAULT>
TOKEN : {
	< MidText :
		">" (<TextChar>)* "<"
	>	
}

<DEFAULT>
TOKEN : {
    < #SymbolChar : 
    	~["\0"-"\37",")"," ","\t","\n","\r",";",",",">","\177"-"\377"] // Octale getallen
    >
}

/*
Parser productions
*/

// Modules is the main node which we start with
SimpleNode Modules() : {/*@bgen(jjtree) Modules */
  ASTModules jjtn000 = new ASTModules(JJTMODULES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modules */
  try {
/*@egen*/
  (Module())* <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

private void Module(): {/*@bgen(jjtree) Module */
  ASTModule jjtn000 = new ASTModule(JJTMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Module */
        try {
/*@egen*/
	< MODULE > ModuleId() (ModuleElement())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ModuleId() : {/*@bgen(jjtree) ModuleId */
  ASTModuleId jjtn000 = new ASTModuleId(JJTMODULEID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ModuleId */
        try {
/*@egen*/
	(< IdCon >{jjtn000.image += "\"" + token.image + "\"";} (< DOT >{jjtn000.image += ", ";})?)+/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void ModuleElement() : {/*@bgen(jjtree) ModuleElement */
  ASTModuleElement jjtn000 = new ASTModuleElement(JJTMODULEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ModuleElement */
                try {
/*@egen*/
		Import()
	|	Site()	
	|	FunctionDef()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

// ModuleElement Import 
// *********************************************
void Import() : {/*@bgen(jjtree) Import */
  ASTImport jjtn000 = new ASTImport(JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Import */
        try {
/*@egen*/ 
	< IMPORT > ModuleId()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
} 

// ModuleElement Site
// *********************************************
void Site() : {/*@bgen(jjtree) Site */
  ASTSite jjtn000 = new ASTSite(JJTSITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Site */
        try {
/*@egen*/
	< SITE > Mappings() < END >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Mappings() : {/*@bgen(jjtree) Mappings */
  ASTMappings jjtn000 = new ASTMappings(JJTMAPPINGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Mappings */
        try {
/*@egen*/
	(Mapping() (<SEMICOLON>)?)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Mapping() : {/*@bgen(jjtree) Mapping */
  ASTMapping jjtn000 = new ASTMapping(JJTMAPPING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Mapping */
        try {
/*@egen*/
	Path() <COLON> Markup()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Path() : {/*@bgen(jjtree) Path */
  ASTPath jjtn000 = new ASTPath(JJTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Path */
        try {
/*@egen*/
	<FileName>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/{jjtn000.image += "path-file:" + token.image;}
	|	<DirName>{jjtn000.image += "path-dirfile:" + token.image.substring(0, token.image.length()-1) + ":";}
		<FileName>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/{jjtn000.image += token.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// ModuleElement FunctionDef
// *********************************************
void FunctionDef() : {/*@bgen(jjtree) FunctionDef */
  ASTFunctionDef jjtn000 = new ASTFunctionDef(JJTFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) FunctionDef */
        try {
/*@egen*/
	<DEF> <IdCon>{jjtn000.image = token.image;} (Formals())? (Statement())+ <END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Formals() : {/*@bgen(jjtree) Formals */
  ASTFormals jjtn000 = new ASTFormals(JJTFORMALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Formals */
        try {
/*@egen*/
	<LPAREN> (<IdCon>{jjtn000.image += token.image;} (<COMMA>{jjtn000.image += token.image;})?)* <RPAREN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statement() : {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Statement */
                try {
/*@egen*/
		<YIELD> <SEMICOLON>/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/ {jjtn000.image = "yield:";}
	|	<COMMENT> <StrCon> {jjtn000.image = "comment:" + token.image;} <SEMICOLON> 
	| 	LOOKAHEAD(Markup() <SEMICOLON>) Markup() <SEMICOLON>/*@bgen(jjtree)*/
                                                                     {
                                                                       jjtree.closeNodeScope(jjtn000, true);
                                                                       jjtc000 = false;
                                                                     }
/*@egen*/ {jjtn000.image = "markup:";}
	|	LOOKAHEAD((Markup())+ <SEMICOLON>) (Markup())+  <SEMICOLON>/*@bgen(jjtree)*/
                                                                           {
                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                             jjtc000 = false;
                                                                           }
/*@egen*/{jjtn000.image = "markup-markup:";}
	|	LOOKAHEAD((Markup())+ Expression() <SEMICOLON>)(
				(LOOKAHEAD(2)Markup())+ Expression() <SEMICOLON>
			)/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.image = "markup-exp:";}
	|	LOOKAHEAD((Markup())+ Statement())(
				(LOOKAHEAD(2)Markup())+ Statement()
			)/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/	{jjtn000.image = "markup-stat:";}	
	|	LOOKAHEAD((Markup())+ Embedding() <SEMICOLON>) (Markup())+ (Embedding() <SEMICOLON>)/*@bgen(jjtree)*/
                                                                                                    {
                                                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                                                      jjtc000 = false;
                                                                                                    }
/*@egen*/{jjtn000.image = "markup-embedding:";}
	|	LOOKAHEAD(4)<LBRACE> (Statement())* <RBRACE>/*@bgen(jjtree)*/
                                                            {
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
                                                            }
/*@egen*/{jjtn000.image = "block:";}
	|	LOOKAHEAD((<IF> <LPAREN> Predicate() <RPAREN> Statement()) <ELSE>) (<IF> <LPAREN> Predicate() <RPAREN> Statement()) <ELSE> Statement()/*@bgen(jjtree)*/
                                                                                                                                                       {
                                                                                                                                                         jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                         jjtc000 = false;
                                                                                                                                                       }
/*@egen*/ {jjtn000.image = "if-else:";}
	|	<IF> <LPAREN> Predicate()<RPAREN> Statement()/*@bgen(jjtree)*/
                                                              {
                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                jjtc000 = false;
                                                              }
/*@egen*/ {jjtn000.image = "if:";}
	|	<EACH> <LPAREN> Var() <COLON> Expression() (DotIdCon())? <RPAREN> Statement()/*@bgen(jjtree)*/
                                                                                              {
                                                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                                                jjtc000 = false;
                                                                                              }
/*@egen*/ {jjtn000.image = "each:";}
	|	LOOKAHEAD(2)<ECHO> Expression() (DotIdCon())? <SEMICOLON>/*@bgen(jjtree)*/
                                                                          {
                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                            jjtc000 = false;
                                                                          }
/*@egen*/ {jjtn000.image = "echo:";}
	|	LOOKAHEAD(2)<ECHO> Embedding() (DotIdCon())? <SEMICOLON>/*@bgen(jjtree)*/
                                                                         {
                                                                           jjtree.closeNodeScope(jjtn000, true);
                                                                           jjtc000 = false;
                                                                         }
/*@egen*/ {jjtn000.image = "echo:";}
	|	<LET> (Assignment())+ <IN> (Statement())* <END>/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                }
/*@egen*/ {jjtn000.image = "let:";}
	|	<CDATA> Expression() (DotIdCon())? <SEMICOLON>/*@bgen(jjtree)*/
                                                               {
                                                                 jjtree.closeNodeScope(jjtn000, true);
                                                                 jjtc000 = false;
                                                               }
/*@egen*/ {jjtn000.image = "cdata:";}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Predicate() : {/*@bgen(jjtree) Predicate */
  ASTPredicate jjtn000 = new ASTPredicate(JJTPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Predicate */
                try {
/*@egen*/
		LOOKAHEAD(2) Expression() (DotIdCon())?
	|	LOOKAHEAD(Expression() (DotIdCon())?)<DOT> <Type>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Assignment() : {/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Assignment */
                try {
/*@egen*/
		LOOKAHEAD(2)<IdCon> {jjtn000.image = "func-bind:" + token.image;} Formals() <ASSIGN> Statement()
	|	LOOKAHEAD(2)<IdCon> {jjtn000.image = "var-bind:" + token.image;} <ASSIGN> Expression() <SEMICOLON>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Embedding() : {/*@bgen(jjtree) Embedding */
  ASTEmbedding jjtn000 = new ASTEmbedding(JJTEMBEDDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Embedding */
        try {
/*@egen*/
	<PreText> {jjtn000.image = token.image;} Embed() TextTail()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Embed() : {/*@bgen(jjtree) Embed */
  ASTEmbed jjtn000 = new ASTEmbed(JJTEMBED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Embed */
        try {
/*@egen*/ 
	(LOOKAHEAD(3) Markup())* (Expression()(DotIdCon())?)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TextTail() : {/*@bgen(jjtree) TextTail */
  ASTTextTail jjtn000 = new ASTTextTail(JJTTEXTTAIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) TextTail */
        try {
/*@egen*/ 
	<PostText>
	|	<MidText> Embed() TextTail()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// Used by both the Site and FunctionDef ModuleElements
// *********************************************
void Markup() : {/*@bgen(jjtree) Markup */
  ASTMarkup jjtn000 = new ASTMarkup(JJTMARKUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Markup */
        try {
/*@egen*/ 
	Designator() (Arguments())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Designator() : {/*@bgen(jjtree) Designator */
  ASTDesignator jjtn000 = new ASTDesignator(JJTDESIGNATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Designator */
        try {
/*@egen*/
	<IdCon>{jjtn000.image = token.image;} (Attribute())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void Attribute() : {/*@bgen(jjtree) Attribute */
  ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Attribute */
                try {
/*@egen*/
		<NUMBER_SIGN> <IdCon>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/{jjtn000.image = "id:" + token.image;}
	|	<DOT> <IdCon>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/{jjtn000.image = "class:" + token.image;}
	|	<DOLLAR_SIGN> <IdCon>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/{jjtn000.image = "name:" + token.image;}
	|	<COLON> <IdCon>/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/{jjtn000.image = "type:" + token.image;}
	| 	LOOKAHEAD(3) <AT> <NatCon>{jjtn000.image = "width-height:" + token.image;} 
		<PERCENT> <NatCon>/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/{jjtn000.image += ", " + token.image;}
	| 	<AT> <NatCon>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/{jjtn000.image += "height:" + token.image;}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Arguments() : {/*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = new ASTArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Arguments */
        try {
/*@egen*/
	<LPAREN> (Argument() (<COMMA>)?)* <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Argument() : {/*@bgen(jjtree) Argument */
  ASTArgument jjtn000 = new ASTArgument(JJTARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Argument */
                try {
/*@egen*/
		LOOKAHEAD(2)<IdCon>{jjtn000.image = token.image;} <ASSIGN> Expression() (DotIdCon())?
	|	Expression() (DotIdCon())?/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void Var() : {/*@bgen(jjtree) Var */
  ASTVar jjtn000 = new ASTVar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Var */
        try {
/*@egen*/
	<IdCon>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.image = token.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
	Note:
	The Expression: Expression() <DOT> <IdCon> has been transformed using the methods
	described in the paper: "Removing Left Recursion from Context-Free Grammars" by Robert C. Moore.
	The result of this transformation was not without problems in JavaCC. This is why the production 
	DotIdCon() was brought into life. It is placed behind each and every call to Expression() in the following way:
	Expression() (DotIdCon())?.  It would be better to keep this inside expression, but attempts in doing so 
	have been unsuccesful thusfar.
*/
void Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression */
                try {
/*@egen*/	
		<SymbolCon>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/{jjtn000.image = "sym:" + token.image;}
	|	<Text>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{jjtn000.image = "text:" + token.image.substring(1,token.image.length() -1);}
	|	<NatCon>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/{jjtn000.image = "num:" + token.image;}
	|	Var()/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/{jjtn000.image = "var:";}
	|	<LBRACKET>{jjtn000.image = "list:";} (Expression() (DotIdCon())? (<COMMA>)? )* <RBRACKET>
	|	<LBRACE>{jjtn000.image = "record:";}(KeyValuePair()  (<COMMA>)? )* <RBRACE>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void DotIdCon() : {/*@bgen(jjtree) DotIdCon */
  ASTDotIdCon jjtn000 = new ASTDotIdCon(JJTDOTIDCON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) DotIdCon */
        try {
/*@egen*/
	<DOT> <IdCon>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.image = token.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void KeyValuePair() : {/*@bgen(jjtree) KeyValuePair */
  ASTKeyValuePair jjtn000 = new ASTKeyValuePair(JJTKEYVALUEPAIR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) KeyValuePair */
        try {
/*@egen*/
	<IdCon>{jjtn000.image = token.image;} <COLON> Expression() (DotIdCon())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
